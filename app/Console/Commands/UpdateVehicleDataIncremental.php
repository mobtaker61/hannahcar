<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Http\Controllers\ApiDataController;
use App\Models\VehicleBrand;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class UpdateVehicleDataIncremental extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'api:update-vehicle-data-incremental
                            {--brand-limit=10 : Number of brands to process in one run}
                            {--force : Force update even if models are completed}
                            {--cleanup : Clean up inactive brands after update}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Update vehicle brands and models incrementally from NHTSA API';

        /**
     * Execute the console command.
     */
    public function handle()
    {
        $this->info('üîÑ Starting incremental vehicle data update from NHTSA API...');

        $brandLimit = (int) $this->option('brand-limit');
        $forceUpdate = $this->option('force');
        $cleanup = $this->option('cleanup');

        // ŸÖÿ±ÿ≠ŸÑŸá 1: ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®ÿ±ŸÜÿØŸáÿß
        $this->info('üìã Step 1: Updating vehicle brands...');
        $brandsResult = $this->updateBrands();

        if (!$brandsResult['success']) {
            $this->error('‚ùå Failed to update brands: ' . $brandsResult['message']);
            return 1;
        }

        $this->info('‚úÖ Brands updated successfully');
        $this->info("   Added: {$brandsResult['data']['added']}");
        $this->info("   Updated: {$brandsResult['data']['updated']}");

        // ŸÖÿ±ÿ≠ŸÑŸá 2: Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ®ÿ±ŸÜÿØŸáÿß Ÿà ŸÖÿØŸÑ‚ÄåŸáÿß€åÿ¥ÿßŸÜ €å⁄©€å €å⁄©€å
        $this->info('üöó Step 2: Processing brands and their models one by one...');
        $modelsResult = $this->processBrandsAndModelsSequentially($brandLimit, $forceUpdate);

        if (!$modelsResult['success']) {
            $this->error('‚ùå Failed to update models: ' . $modelsResult['message']);
            return 1;
        }

        $this->info('‚úÖ Models updated successfully');
        $this->info("   Brands processed: {$modelsResult['data']['brands_processed']}");
        $this->info("   Models added: {$modelsResult['data']['models_added']}");
        $this->info("   Models updated: {$modelsResult['data']['models_updated']}");

        // ŸÜŸÖÿß€åÿ¥ Ÿàÿ∂ÿπ€åÿ™ ⁄©ŸÑ€å
        $this->displayOverallStatus();

        // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ®ÿ±ŸÜÿØŸáÿß€å ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿß⁄Øÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ
        if ($cleanup) {
            $this->info('üßπ Cleaning up inactive brands...');
            $controller = new ApiDataController();
            $cleanupResult = $controller->cleanupInactiveBrands();
            $this->info('‚úÖ ' . $cleanupResult['message']);
        }

        $this->info('üéâ Incremental update completed successfully!');
        return 0;
    }

    /**
     * ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®ÿ±ŸÜÿØŸáÿß
     */
    private function updateBrands()
    {
        try {
            Log::info('Starting vehicle brands update from NHTSA API');

            // ÿØÿ±€åÿßŸÅÿ™ ÿØÿßÿØŸá‚ÄåŸáÿß ÿßÿ≤ API
            $response = Http::get('https://vpic.nhtsa.dot.gov/api/vehicles/getallmakes?format=json');

            if (!$response->successful()) {
                Log::error('Failed to fetch data from NHTSA API', [
                    'status' => $response->status(),
                    'body' => $response->body()
                ]);
                return [
                    'success' => false,
                    'message' => 'ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿØÿßÿØŸá‚ÄåŸáÿß ÿßÿ≤ API',
                    'status' => $response->status()
                ];
            }

            $data = $response->json();

            if (!isset($data['Results']) || !is_array($data['Results'])) {
                Log::error('Invalid response format from NHTSA API', ['data' => $data]);
                return [
                    'success' => false,
                    'message' => 'ŸÅÿ±ŸÖÿ™ Ÿæÿßÿ≥ÿÆ API ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™'
                ];
            }

            $brands = $data['Results'];
            $added = 0;
            $updated = 0;
            $skipped = 0;

            foreach ($brands as $brandData) {
                if (!isset($brandData['Make_Name']) || empty($brandData['Make_Name'])) {
                    $skipped++;
                    continue;
                }

                $name = trim($brandData['Make_Name']);
                $slug = Str::slug($name);
                $makeId = $brandData['Make_ID'] ?? null;

                // ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ¨ŸàÿØ ÿ®ÿ±ŸÜÿØ ÿ®ÿß ŸáŸÖ€åŸÜ ŸÜÿßŸÖ €åÿß slug
                $existingBrand = VehicleBrand::where('name', $name)
                    ->orWhere('slug', $slug)
                    ->first();

                if ($existingBrand) {
                    // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®ÿ±ŸÜÿØ ŸÖŸàÿ¨ŸàÿØ
                    $existingBrand->update([
                        'name' => $name,
                        'slug' => $slug,
                        'is_active' => true,
                        'sort_order' => $existingBrand->sort_order ?? 0
                    ]);
                    $updated++;
                    Log::info("Updated existing brand: {$name}");
                } else {
                    // ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ®ÿ±ŸÜÿØ ÿ¨ÿØ€åÿØ
                    VehicleBrand::create([
                        'name' => $name,
                        'slug' => $slug,
                        'is_active' => true,
                        'sort_order' => 0,
                        'description' => "ÿ®ÿ±ŸÜÿØ ÿÆŸàÿØÿ±Ÿà: {$name}",
                        'website' => null,
                        'models_completed' => false,
                        'models_updated_at' => null
                    ]);
                    $added++;
                    Log::info("Added new brand: {$name}");
                }
            }

            Log::info('Vehicle brands update completed', [
                'added' => $added,
                'updated' => $updated,
                'skipped' => $skipped,
                'total_processed' => count($brands)
            ]);

            return [
                'success' => true,
                'message' => 'ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®ÿ±ŸÜÿØŸáÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ',
                'data' => [
                    'added' => $added,
                    'updated' => $updated,
                    'skipped' => $skipped,
                    'total_processed' => count($brands)
                ]
            ];

        } catch (\Exception $e) {
            Log::error('Error updating vehicle brands', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return [
                'success' => false,
                'message' => 'ÿÆÿ∑ÿß ÿØÿ± ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®ÿ±ŸÜÿØŸáÿß: ' . $e->getMessage()
            ];
        }
    }

        /**
     * Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ®ÿ±ŸÜÿØŸáÿß Ÿà ŸÖÿØŸÑ‚ÄåŸáÿß€åÿ¥ÿßŸÜ €å⁄©€å €å⁄©€å
     */
    private function processBrandsAndModelsSequentially($limit, $forceUpdate = false)
    {
        try {
            Log::info('Starting sequential brand and model processing');

            // ÿØÿ±€åÿßŸÅÿ™ ÿ®ÿ±ŸÜÿØŸáÿß€å€å ⁄©Ÿá ŸÖÿØŸÑ‚ÄåŸáÿß€åÿ¥ÿßŸÜ ⁄©ÿßŸÖŸÑ ŸÜÿ¥ÿØŸá €åÿß force update ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ÿØŸá
            $query = VehicleBrand::where('is_active', true);

            if (!$forceUpdate) {
                $query->where(function($q) {
                    $q->where('models_completed', false)
                      ->orWhereNull('models_updated_at');
                });
            }

            $brands = $query->orderBy('id')->limit($limit)->get();

            if ($brands->isEmpty()) {
                $this->info('‚úÖ All brands have been processed!');
                return [
                    'success' => true,
                    'message' => 'Ÿá€å⁄Ü ÿ®ÿ±ŸÜÿØ€å ÿ®ÿ±ÿß€å ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ',
                    'data' => [
                        'brands_processed' => 0,
                        'models_added' => 0,
                        'models_updated' => 0
                    ]
                ];
            }

            $this->info("üîÑ Processing {$brands->count()} brands sequentially...");
            $this->newLine();

            $brandsProcessed = 0;
            $totalModelsAdded = 0;
            $totalModelsUpdated = 0;
            $errors = 0;

            foreach ($brands as $index => $brand) {
                $brandNumber = $index + 1;
                $this->info("üìã Brand {$brandNumber}/{$brands->count()}: {$brand->name} (ID: {$brand->id})");

                try {
                    $this->info("   üîÑ Fetching models for {$brand->name}...");
                    $result = $this->updateModelsForBrand($brand);

                    if ($result['success']) {
                        $brandsProcessed++;
                        $totalModelsAdded += $result['data']['added'];
                        $totalModelsUpdated += $result['data']['updated'];

                        // ÿπŸÑÿßŸÖÿ™‚Äå⁄Øÿ∞ÿßÿ±€å ÿ®ÿ±ŸÜÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ⁄©ÿßŸÖŸÑ
                        $brand->update([
                            'models_completed' => true,
                            'models_updated_at' => now()
                        ]);

                        $this->info("   ‚úÖ {$brand->name} completed successfully!");
                        $this->info("      üìä Models: Added {$result['data']['added']}, Updated {$result['data']['updated']}, Skipped {$result['data']['skipped']}");
                        $this->info("      üìÖ Last updated: " . now()->format('Y-m-d H:i:s'));

                    } else {
                        $errors++;
                        $this->warn("   ‚ö†Ô∏è Failed to process {$brand->name}: {$result['message']}");
                    }

                } catch (\Exception $e) {
                    $errors++;
                    Log::error("Error processing models for brand {$brand->name}", [
                        'brand_id' => $brand->id,
                        'error' => $e->getMessage()
                    ]);
                    $this->warn("   ‚ùå Error processing {$brand->name}: {$e->getMessage()}");
                }

                $this->newLine();
            }

            // ŸÜŸÖÿß€åÿ¥ ÿÆŸÑÿßÿµŸá ŸÜÿ™ÿß€åÿ¨
            $this->info('üìä Processing Summary:');
            $this->info("   ‚úÖ Brands processed successfully: {$brandsProcessed}");
            $this->info("   üìà Total models added: {$totalModelsAdded}");
            $this->info("   üîÑ Total models updated: {$totalModelsUpdated}");
            if ($errors > 0) {
                $this->warn("   ‚ö†Ô∏è Errors encountered: {$errors}");
            }

            Log::info('Sequential brand and model processing completed', [
                'brands_processed' => $brandsProcessed,
                'models_added' => $totalModelsAdded,
                'models_updated' => $totalModelsUpdated,
                'errors' => $errors
            ]);

            return [
                'success' => true,
                'message' => 'Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ®ÿ±ŸÜÿØŸáÿß Ÿà ŸÖÿØŸÑ‚ÄåŸáÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ',
                'data' => [
                    'brands_processed' => $brandsProcessed,
                    'models_added' => $totalModelsAdded,
                    'models_updated' => $totalModelsUpdated,
                    'errors' => $errors
                ]
            ];

        } catch (\Exception $e) {
            Log::error('Error in sequential brand and model processing', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return [
                'success' => false,
                'message' => 'ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ®ÿ±ŸÜÿØŸáÿß Ÿà ŸÖÿØŸÑ‚ÄåŸáÿß: ' . $e->getMessage()
            ];
        }
    }

    /**
     * ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖÿØŸÑ‚ÄåŸáÿß€å €å⁄© ÿ®ÿ±ŸÜÿØ ÿÆÿßÿµ
     */
    private function updateModelsForBrand(VehicleBrand $brand)
    {
        try {
            // ÿØÿ±€åÿßŸÅÿ™ ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿØ ÿßÿ≤ API
            $response = Http::get("https://vpic.nhtsa.dot.gov/api/vehicles/GetModelsForMakeId/{$brand->id}?format=json");

            if (!$response->successful()) {
                Log::warning("Failed to fetch models for brand {$brand->name}", [
                    'brand_id' => $brand->id,
                    'status' => $response->status()
                ]);
                return [
                    'success' => false,
                    'message' => "ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿØ {$brand->name}"
                ];
            }

            $data = $response->json();

            if (!isset($data['Results']) || !is_array($data['Results'])) {
                Log::warning("Invalid response format for brand {$brand->name}", ['data' => $data]);
                return [
                    'success' => false,
                    'message' => "ŸÅÿ±ŸÖÿ™ Ÿæÿßÿ≥ÿÆ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿ®ÿ±ÿß€å ÿ®ÿ±ŸÜÿØ {$brand->name}"
                ];
            }

            $models = $data['Results'];
            $added = 0;
            $updated = 0;
            $skipped = 0;

            foreach ($models as $modelData) {
                if (!isset($modelData['Model_Name']) || empty($modelData['Model_Name'])) {
                    $skipped++;
                    continue;
                }

                $name = trim($modelData['Model_Name']);
                $baseSlug = Str::slug($name);

                // ÿ™ŸàŸÑ€åÿØ slug €å⁄©ÿ™ÿß
                $slug = $this->generateUniqueSlug($baseSlug, $brand->id);

                // ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ¨ŸàÿØ ŸÖÿØŸÑ ÿ®ÿß ŸáŸÖ€åŸÜ ŸÜÿßŸÖ ÿØÿ± ÿß€åŸÜ ÿ®ÿ±ŸÜÿØ
                $existingModel = \App\Models\VehicleModel::where('brand_id', $brand->id)
                    ->where('name', $name)
                    ->first();

                if ($existingModel) {
                    // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖÿØŸÑ ŸÖŸàÿ¨ŸàÿØ
                    $existingModel->update([
                        'name' => $name,
                        'slug' => $slug,
                        'is_active' => true,
                        'sort_order' => $existingModel->sort_order ?? 0
                    ]);
                    $updated++;
                } else {
                    // ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸÖÿØŸÑ ÿ¨ÿØ€åÿØ
                    try {
                        \App\Models\VehicleModel::create([
                            'brand_id' => $brand->id,
                            'name' => $name,
                            'slug' => $slug,
                            'is_active' => true,
                            'sort_order' => 0,
                            'description' => "ŸÖÿØŸÑ {$name} ÿßÿ≤ ÿ®ÿ±ŸÜÿØ {$brand->name}"
                        ]);
                        $added++;
                    } catch (\Illuminate\Database\QueryException $e) {
                        // ÿß⁄Øÿ± ŸáŸÜŸàÿ≤ ÿÆÿ∑ÿß€å duplicate entry ÿØÿßÿ¥ÿ™€åŸÖÿå slug ÿ¨ÿØ€åÿØ ÿ™ŸàŸÑ€åÿØ ⁄©ŸÜ€åŸÖ
                        if ($e->getCode() == 23000 && str_contains($e->getMessage(), 'Duplicate entry')) {
                            $slug = $this->generateUniqueSlug($baseSlug, $brand->id, true);
                            \App\Models\VehicleModel::create([
                                'brand_id' => $brand->id,
                                'name' => $name,
                                'slug' => $slug,
                                'is_active' => true,
                                'sort_order' => 0,
                                'description' => "ŸÖÿØŸÑ {$name} ÿßÿ≤ ÿ®ÿ±ŸÜÿØ {$brand->name}"
                            ]);
                            $added++;
                        } else {
                            throw $e;
                        }
                    }
                }
            }

            Log::info("Processed models for brand: {$brand->name}", [
                'brand_id' => $brand->id,
                'models_count' => count($models),
                'added' => $added,
                'updated' => $updated,
                'skipped' => $skipped
            ]);

            return [
                'success' => true,
                'message' => "ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿØ {$brand->name} ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ",
                'data' => [
                    'added' => $added,
                    'updated' => $updated,
                    'skipped' => $skipped,
                    'total' => count($models)
                ]
            ];

        } catch (\Exception $e) {
            Log::error("Error processing models for brand {$brand->name}", [
                'brand_id' => $brand->id,
                'error' => $e->getMessage()
            ]);

            return [
                'success' => false,
                'message' => "ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿØ {$brand->name}: " . $e->getMessage()
            ];
        }
    }

    /**
     * ÿ™ŸàŸÑ€åÿØ slug €å⁄©ÿ™ÿß ÿ®ÿ±ÿß€å ŸÖÿØŸÑ
     */
    private function generateUniqueSlug($baseSlug, $brandId, $forceUnique = false)
    {
        $slug = $baseSlug;
        $counter = 1;

        // ÿß⁄Øÿ± forceUnique ÿ®ÿßÿ¥ÿØÿå ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß ÿ®ÿß ÿ¥ŸÖÿßÿ±Ÿá ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åŸÖ
        if ($forceUnique) {
            $slug = $baseSlug . '-' . $counter;
            $counter++;
        }

        // ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ¨ŸàÿØ slug ÿØÿ± ⁄©ŸÑ ÿ¨ÿØŸàŸÑ
        while (\App\Models\VehicleModel::where('slug', $slug)->exists()) {
            $slug = $baseSlug . '-' . $counter;
            $counter++;
        }

        return $slug;
    }

    /**
     * ŸÜŸÖÿß€åÿ¥ Ÿàÿ∂ÿπ€åÿ™ ⁄©ŸÑ€å
     */
    private function displayOverallStatus()
    {
        $totalBrands = VehicleBrand::count();
        $activeBrands = VehicleBrand::where('is_active', true)->count();
        $completedBrands = VehicleBrand::where('models_completed', true)->count();
        $pendingBrands = $activeBrands - $completedBrands;

        $totalModels = \App\Models\VehicleModel::count();
        $activeModels = \App\Models\VehicleModel::where('is_active', true)->count();

        $this->info('üìä Overall Status:');
        $this->info("   Total brands: {$totalBrands}");
        $this->info("   Active brands: {$activeBrands}");
        $this->info("   Brands with completed models: {$completedBrands}");
        $this->info("   Brands pending model update: {$pendingBrands}");
        $this->info("   Total models: {$totalModels}");
        $this->info("   Active models: {$activeModels}");

        if ($pendingBrands > 0) {
            $this->warn("‚ö†Ô∏è {$pendingBrands} brands still need model updates. Run this command again to continue.");
        } else {
            $this->info('üéâ All brands have been processed!');
        }
    }
}
